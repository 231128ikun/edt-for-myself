import { connect } from 'cloudflare:sockets';

const USER_ID = 'aaa6b096-1165-4bbe-935c-99f4ec902d02';
const PROXY_IP = 'sjc.o00o.ooo:443';

const HIGH_THROUGHPUT = true;

const connectionPool = new Map();
const POOL_TIMEOUT = 60000;
const CONNECT_TIMEOUT = 30000;

const WS_BP_HIGH = HIGH_THROUGHPUT ? 1024 * 1024 : 256 * 1024;
const WS_BP_LOW = HIGH_THROUGHPUT ? 512 * 1024 : 128 * 1024;

function isValidUUID(uuid) {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidRegex.test(uuid);
}
if (!isValidUUID(USER_ID)) throw new Error('Invalid USER_ID format');

function cleanupConnectionPool() {
  const now = Date.now();
  for (const [key, entry] of connectionPool.entries()) {
    if (now - entry.lastUsed > POOL_TIMEOUT) {
      try { entry.socket.close(); } catch {}
      connectionPool.delete(key);
    }
  }
}

export default {
  async fetch(request) {
    cleanupConnectionPool();
    try {
      const up = request.headers.get('Upgrade');
      if (!up || up.toLowerCase() !== 'websocket') {
        return new Response('Only WebSocket endpoint', { status: 400 });
      }
      return await vlessOverWSHandler(request);
    } catch (err) {
      return new Response(String(err), { status: 500 });
    }
  }
};

async function vlessOverWSHandler(request) {
  const wsPair = new WebSocketPair();
  const client = wsPair[0], server = wsPair[1];
  server.accept();

  const earlyDataHeader = request.headers.get('sec-websocket-protocol') || '';
  const readableWS = makeReadableWebSocketStream(server, earlyDataHeader);

  let remoteSocketRef = { value: null };
  let udpWriter = null;
  let isDnsMode = false;

  readableWS.pipeTo(new WritableStream({
    async write(chunk) {
      const data = normalizeToUint8Array(chunk);
      if (!data.length) return;

      if (isDnsMode && udpWriter) return udpWriter(data);

      if (remoteSocketRef.value) {
        await bufferedWrite(remoteSocketRef.value, data);
        return;
      }

      const parsed = processVlessHeader(data.buffer, USER_ID);
      if (parsed.hasError) throw new Error(parsed.message);

      const { addressRemote, portRemote, rawDataIndex, vlessVersion, isUDP } = parsed;
      if (isUDP) {
        if (portRemote !== 53) throw new Error('UDP proxy only for DNS (port 53)');
        isDnsMode = true;
      }

      const vlessRespHeader = new Uint8Array([vlessVersion[0], 0]);
      const initialPayload = data.slice(rawDataIndex);

      if (isDnsMode) {
        const writer = await handleUDPOutBound(server, vlessRespHeader, addressRemote, portRemote);
        udpWriter = writer.write.bind(writer);
        if (initialPayload.length) udpWriter(initialPayload);
        return;
      }

      handleTCPOutBound(remoteSocketRef, addressRemote, portRemote, initialPayload, server, vlessRespHeader);
    }
  })).catch(() => {});

  return new Response(null, { status: 101, webSocket: client });
}

function processVlessHeader(vlessBuffer, userID) {
  if (!vlessBuffer || vlessBuffer.byteLength < 24) return { hasError: true, message: 'invalid data' };
  const data = new Uint8Array(vlessBuffer);
  const version = data[0];
  const userBytes = Uint8Array.from(userID.replace(/-/g, '').match(/.{2}/g).map(x => parseInt(x, 16)));
  for (let i = 0; i < 16; i++) if (data[1 + i] !== userBytes[i]) return { hasError: true, message: 'invalid user' };
  const optLen = data[17], cmd = data[18 + optLen];
  if (cmd !== 1 && cmd !== 2) return { hasError: true, message: `unsupported command ${cmd}` };
  const isUDP = cmd === 2;
  const portIndex = 18 + optLen + 1;
  const portRemote = new DataView(vlessBuffer, portIndex, 2).getUint16(0);
  let addressIndex = portIndex + 2, addressRemote = '';
  const addrType = data[addressIndex++];
  if (addrType === 1) { addressRemote = Array.from(data.slice(addressIndex, addressIndex + 4)).join('.'); addressIndex += 4; }
  else if (addrType === 2) { const len = data[addressIndex++]; addressRemote = new TextDecoder().decode(vlessBuffer.slice(addressIndex, addressIndex + len)); addressIndex += len; }
  else if (addrType === 3) { const dv = new DataView(vlessBuffer, addressIndex, 16); const parts = []; for (let i = 0; i < 8; i++) parts.push(dv.getUint16(i * 2).toString(16)); addressRemote = parts.join(':'); addressIndex += 16; }
  else return { hasError: true, message: 'invalid address type' };
  return { hasError: false, addressRemote, portRemote, rawDataIndex: addressIndex, vlessVersion: new Uint8Array([version]), isUDP };
}

async function handleTCPOutBound(remoteRef, address, port, firstPayload, serverWS, vlessRespHeader) {
  const key = `${address}:${port}`;
  let entry = connectionPool.get(key);

  async function connectNew() {
    const sock = connect({ hostname: address, port });
    let timeoutId;
    try {
      await Promise.race([
        sock.opened,
        new Promise((_, reject) => { timeoutId = setTimeout(() => reject(new Error('connect timeout')), CONNECT_TIMEOUT); })
      ]);
      if (timeoutId) clearTimeout(timeoutId);
    } catch (err) {
      if (timeoutId) clearTimeout(timeoutId);
      throw err;
    }
    const e = { socket: sock, lastUsed: Date.now() };
    connectionPool.set(key, e);
    return e;
  }

  try {
    if (!entry || entry.socket.closed) {
      entry = await connectNew();
    } else {
      entry.lastUsed = Date.now();
    }
    remoteRef.value = entry.socket;
    if (firstPayload.length) await bufferedWrite(entry.socket, firstPayload);
    remoteSocketToWS(entry.socket, serverWS, vlessRespHeader);
    return;
  } catch (e) {
    console.error('Direct connect failed:', address, port, e.message);
  }

  const [ph, pp] = parseHostPort(PROXY_IP, port);
  try {
    const sock = connect({ hostname: ph, port: pp });
    let timeoutId;
    try {
      await Promise.race([
        sock.opened,
        new Promise((_, reject) => { timeoutId = setTimeout(() => reject(new Error('proxy timeout')), CONNECT_TIMEOUT); })
      ]);
      if (timeoutId) clearTimeout(timeoutId);
    } catch (err) {
      if (timeoutId) clearTimeout(timeoutId);
      throw err;
    }
    remoteRef.value = sock;
    if (firstPayload.length) await bufferedWrite(sock, firstPayload);
    remoteSocketToWS(sock, serverWS, vlessRespHeader);
  } catch (e) {
    console.error('Proxy connect failed:', ph, pp, e.message);
    try { serverWS.close(); } catch {}
  }
}

async function remoteSocketToWS(remoteSock, serverWS, vlessRespHeader) {
  let header = vlessRespHeader;
  const reader = remoteSock.readable.getReader();
  try {
    while (true) {
      if (serverWS.bufferedAmount > WS_BP_HIGH) {
        await waitForWSDrain(serverWS);
      }
      const { value, done } = await reader.read();
      if (done) break;
      if (!value) continue;
      const u8 = normalizeToUint8Array(value);
      if (header) {
        const buf = new Uint8Array(header.length + u8.length);
        buf.set(header, 0); buf.set(u8, header.length);
        serverWS.send(buf);
        header = null;
      } else {
        serverWS.send(u8);
      }
    }
  } finally { try { reader.releaseLock(); } catch {} }
}

async function bufferedWrite(sock, chunk) {
  if (!sock._queue) sock._queue = Promise.resolve();
  sock._queue = sock._queue.then(async () => {
    const w = sock.writable.getWriter();
    try { await w.write(chunk); } catch {}
    try { w.releaseLock(); } catch {}
  });
}

async function waitForWSDrain(ws) {
  while (ws.bufferedAmount > WS_BP_LOW) {
    await new Promise(r => setTimeout(r, 10));
  }
}

// --- UDP 回归祖师爷原版 --- 
async function handleUDPOutBound(serverWS, vlessRespHeader, address, port) {
  const udpSocket = connect({ hostname: address, port });
  await udpSocket.opened;

  const writer = udpSocket.writable.getWriter();
  serverWS.send(vlessRespHeader);

  return {
    write: async (chunk) => {
      try { await writer.write(chunk); } catch {}
    }
  };
}

function normalizeToUint8Array(x) {
  if (!x) return new Uint8Array(0);
  if (x instanceof Uint8Array) return x;
  if (x instanceof ArrayBuffer) return new Uint8Array(x);
  if (ArrayBuffer.isView(x)) return new Uint8Array(x.buffer, x.byteOffset, x.byteLength);
  return new Uint8Array(0);
}

function base64UrlToUint8Array(b64) {
  if (!b64) return { earlyData: null, error: null };
  try {
    let s = b64.replace(/-/g, '+').replace(/_/g, '/');
    while (s.length % 4) s += '=';
    const raw = atob(s);
    return { earlyData: Uint8Array.from(raw, c => c.charCodeAt(0)), error: null };
  } catch (e) {
    return { earlyData: null, error: e };
  }
}

function makeReadableWebSocketStream(webSocketServer, earlyDataHeader) {
  let canceled = false;
  return new ReadableStream({
    start(controller) {
      webSocketServer.addEventListener('message', (evt) => { if (!canceled) controller.enqueue(evt.data); });
      webSocketServer.addEventListener('close', () => { if (!canceled) controller.close(); });
      webSocketServer.addEventListener('error', (err) => { controller.error(err); });
      const { earlyData } = base64UrlToUint8Array(earlyDataHeader);
      if (earlyData) controller.enqueue(earlyData);
    },
    cancel() { canceled = true; try { webSocketServer.close(); } catch {} }
  });
}

function parseHostPort(str, defaultPort = 443) {
  if (!str) return [null, defaultPort];
  if (str.includes(']:')) { const host = str.split(']:')[0] + ']'; const port = Number(str.split(']:')[1]) || defaultPort; return [host, port]; }
  else if (str.split(':').length === 2) { const [h, p] = str.split(':'); return [h, Number(p) || defaultPort]; }
  else return [str, defaultPort];
}
