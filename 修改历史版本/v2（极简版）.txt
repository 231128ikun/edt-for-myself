import { connect } from 'cloudflare:sockets';

// ==================== 固定配置 ====================
const CONFIG = {
  userId: '123456',
  uuid: 'aaa6b096-1165-4bbe-935c-99f4ec902d02',
  nodeName: 'IKUN-Vless',
  bestIPs: [
    'developers.cloudflare.com',
    'ip.sb',
    'www.visa.cn',
    'ikun.glimmer.cf.090227.xyz'
  ],
  proxyIP: 'sjc.o00o.ooo:443',
  uuidBytes: parseUUID('aaa6b096-1165-4bbe-935c-99f4ec902d02')
};

// 全局 TextDecoder（复用，避免频繁创建）
const textDecoder = new TextDecoder();

// ==================== 工具函数 ====================
function parseUUID(uuid) {
  const hex = uuid.replace(/-/g, '');
  const bytes = new Uint8Array(16);
  for (let i = 0; i < 16; i++) {
    bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
  }
  return bytes;
}

function compareUUIDs(uuid1, uuid2) {
  if (uuid1.length !== uuid2.length) return false;
  for (let i = 0; i < uuid1.length; i++) {
    if (uuid1[i] !== uuid2[i]) return false;
  }
  return true;
}

function parseVlessHeader(buffer) {
  if (buffer.length < 18) return null;

  const uuid = buffer.subarray(1, 17);
  const optLen = buffer[17];
  let idx = 18 + optLen;
  if (buffer.length < idx + 3) return null;

  idx++; // 跳过命令
  const port = (buffer[idx] << 8) | buffer[idx + 1];
  idx += 2;

  const addrType = buffer[idx++];
  let addr, addrLen;

  switch (addrType) {
    case 1: // IPv4
      addr = `${buffer[idx]}.${buffer[idx + 1]}.${buffer[idx + 2]}.${buffer[idx + 3]}`;
      addrLen = 4;
      break;
    case 2: // Domain
      addrLen = buffer[idx++];
      addr = textDecoder.decode(buffer.subarray(idx, idx + addrLen));
      break;
    case 3: // IPv6
      addrLen = 16;
      const parts = new Array(8);
      for (let i = 0; i < 8; i++) {
        const offset = idx + i * 2;
        parts[i] = ((buffer[offset] << 8) | buffer[offset + 1]).toString(16);
      }
      addr = parts.join(':');
      break;
    default:
      return null;
  }

  return {
    uuid,
    port,
    address: addr,
    addressType: addrType,
    initialData: buffer.subarray(idx + addrLen)
  };
}

// ==================== 数据转发 ====================
async function handleWSToSocket(ws, writer) {
  return new Promise((resolve, reject) => {
    ws.addEventListener('message', ({ data }) => {
      writer.write(new Uint8Array(data)).catch(reject);
    });
    ws.addEventListener('close', resolve);
    ws.addEventListener('error', reject);
  });
}

async function handleSocketToWS(socket, ws) {
  const reader = socket.readable.getReader();
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      if (ws.readyState !== WebSocket.OPEN) break;

      // 背压控制（避免内存堆积）
      if (ws.bufferedAmount > 1024 * 1024) {
        await new Promise(r => setTimeout(r, 10));
      }

      ws.send(value);
    }
  } finally {
    reader.releaseLock();
  }
}

async function streamTransfer(ws, socket, initialData) {
  const writer = socket.writable.getWriter();
  ws.send(new Uint8Array([0, 0])); // 响应成功
  if (initialData?.length > 0) await writer.write(initialData);

  try {
    await Promise.race([
      handleWSToSocket(ws, writer),
      handleSocketToWS(socket, ws)
    ]);
  } finally {
    try { writer.close(); } catch {}
    try { ws.close(); } catch {}
  }
}

// ==================== WebSocket处理 ====================
async function handleWebSocket(request) {
  const protocol = request.headers.get('sec-websocket-protocol');
  if (!protocol) return new Response('400', { status: 400 });

  let protocolData;
  try {
    const base64 = protocol.replace(/-/g, '+').replace(/_/g, '/');
    protocolData = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
  } catch {
    return new Response('400', { status: 400 });
  }

  const vlessData = parseVlessHeader(protocolData);
  if (!vlessData) return new Response('400', { status: 400 });

  const { uuid, port, address, addressType, initialData } = vlessData;
  if (!compareUUIDs(uuid, CONFIG.uuidBytes)) {
    return new Response('403', { status: 403 });
  }

  let socket;
  try {
    socket = await connect({
      hostname: addressType === 3 ? `[${address}]` : address,
      port
    });
    await socket.opened;
  } catch {
    return new Response('502', { status: 502 });
  }

  const [client, server] = new WebSocketPair();
  server.accept();
  streamTransfer(server, socket, initialData).catch(() => {});
  return new Response(null, { status: 101, webSocket: client });
}

// ==================== 节点生成（全局缓存） ====================
let cachedConfig = null;
function getVlessConfig(host) {
  if (cachedConfig && cachedConfig.host === host) return cachedConfig.text;

  const text = [...CONFIG.bestIPs, `${host}:443`]
    .map(ip => {
      const [addr, port = 443] = ip.split(':');
      return `vless://${CONFIG.uuid}@${addr}:${port}?encryption=none&security=tls&type=ws&host=${host}&sni=${host}&path=%2F%3Fed%3D2560#${CONFIG.nodeName}`;
    })
    .join('\n');

  cachedConfig = { host, text };
  return text;
}

// ==================== 主入口 ====================
export default {
  async fetch(request) {
    const url = new URL(request.url);
    const host = request.headers.get('Host');

    if (request.headers.get('Upgrade') === 'websocket') {
      return await handleWebSocket(request);
    }

    if (url.pathname === `/${CONFIG.userId}/vless`) {
      return new Response(getVlessConfig(host), {
        headers: { 'Content-Type': 'text/plain; charset=utf-8' }
      });
    }

    return new Response('404', { status: 404 });
  }
};
